package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"

	"github.com/aashiq-04/session-management-system/backend/gateway/graph/generated"
	"github.com/aashiq-04/session-management-system/backend/gateway/graph/model"
	"github.com/aashiq-04/session-management-system/backend/gateway/middleware"
	auditpb "github.com/aashiq-04/session-management-system/backend/gateway/proto/audit"
	authpb "github.com/aashiq-04/session-management-system/backend/gateway/proto/auth"
	sessionpb "github.com/aashiq-04/session-management-system/backend/gateway/proto/session"
)
//HELPER FUNCTIONS
func strPtrToVal(s *string) string {
    if s == nil {
        return ""
    }
    return *s
}

func floatPtrToVal(f *float64) float64 {
    if f == nil {
        return 0
    }
    return *f
}

// Register creates a new user account
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	deviceInfo := &authpb.DeviceInfo{
		DeviceFingerprint: input.DeviceInfo.DeviceFingerprint,
		DeviceName:        input.DeviceInfo.DeviceName,
		DeviceType:        input.DeviceInfo.DeviceType,
		Os:                input.DeviceInfo.Os,
		Browser:           input.DeviceInfo.Browser,
		IpAddress:         input.DeviceInfo.IPAddress,
		UserAgent:         input.DeviceInfo.UserAgent,
		LocationCountry:   strPtrToVal(input.DeviceInfo.LocationCountry),
		LocationCity:      strPtrToVal(input.DeviceInfo.LocationCity),
		Latitude:          floatPtrToVal(input.DeviceInfo.Latitude),
		Longitude:         floatPtrToVal(input.DeviceInfo.Longitude),
	
	}

	resp, err := r.Clients.AuthClient.Register(ctx, &authpb.RegisterRequest{
		Email:      input.Email,
		Password:   input.Password,
		FullName:   input.FullName,
		DeviceInfo: deviceInfo,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to register: %w", err)
	}

	return &model.AuthPayload{
		Success:      resp.Success,
		Message:      resp.Message,
		UserID:       &resp.UserId,
		AccessToken:  &resp.AccessToken,
		RefreshToken: &resp.RefreshToken,
	}, nil
}

// Login authenticates a user
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	deviceInfo := &authpb.DeviceInfo{
		DeviceFingerprint: input.DeviceInfo.DeviceFingerprint,
		DeviceName:        input.DeviceInfo.DeviceName,
		DeviceType:        input.DeviceInfo.DeviceType,
		Os:                input.DeviceInfo.Os,
		Browser:           input.DeviceInfo.Browser,
		IpAddress:         input.DeviceInfo.IPAddress,
		UserAgent:         input.DeviceInfo.UserAgent,
		LocationCountry:   strPtrToVal(input.DeviceInfo.LocationCountry),
   		LocationCity:      strPtrToVal(input.DeviceInfo.LocationCity),
    	Latitude:          floatPtrToVal(input.DeviceInfo.Latitude),
    	Longitude:         floatPtrToVal(input.DeviceInfo.Longitude),
	}

	mfaCode := ""
	if input.MfaCode != nil {
		mfaCode = *input.MfaCode
	}

	resp, err := r.Clients.AuthClient.Login(ctx, &authpb.LoginRequest{
		Email:      input.Email,
		Password:   input.Password,
		DeviceInfo: deviceInfo,
		MfaCode:    mfaCode,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to login: %w", err)
	}

	mfaRequired := resp.MfaRequired

	return &model.AuthPayload{
		Success:      resp.Success,
		Message:      resp.Message,
		UserID:       &resp.UserId,
		AccessToken:  &resp.AccessToken,
		RefreshToken: &resp.RefreshToken,
		MfaRequired:  &mfaRequired,
		SessionID:    &resp.SessionId,
	}, nil
}

// RefreshToken generates a new access token
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error) {
	resp, err := r.Clients.AuthClient.RefreshToken(ctx, &authpb.RefreshTokenRequest{
		RefreshToken: refreshToken,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to refresh token: %w", err)
	}

	return &model.AuthPayload{
		Success:      resp.Success,
		Message:      resp.Message,
		AccessToken:  &resp.AccessToken,
		RefreshToken: &resp.RefreshToken,
	}, nil
}

// EnableMfa is the resolver for the enableMFA field.
func (r *mutationResolver) EnableMfa(ctx context.Context) (*model.MFASetup, error) {
	panic(fmt.Errorf("not implemented: EnableMfa - enableMFA"))
}

// VerifyMfa is the resolver for the verifyMFA field.
func (r *mutationResolver) VerifyMfa(ctx context.Context, code string) (*model.GenericResponse, error) {
	panic(fmt.Errorf("not implemented: VerifyMfa - verifyMFA"))
}

// RevokeSession revokes a specific session
func (r *mutationResolver) RevokeSession(ctx context.Context, sessionID string) (*model.GenericResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.SessionClient.RevokeSession(ctx, &sessionpb.RevokeSessionRequest{
		SessionId:   sessionID,
		UserId:      user.UserID,
		RevokedByIp: "gateway",
		Reason:      "user_requested",
	})

	if err != nil {
		return nil, fmt.Errorf("failed to revoke session: %w", err)
	}

	return &model.GenericResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// RevokeAllSessions revokes all sessions for the current user
func (r *mutationResolver) RevokeAllSessions(ctx context.Context, exceptCurrent *bool) (*model.GenericResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	exceptCurrentValue := false
	if exceptCurrent != nil {
		exceptCurrentValue = *exceptCurrent
	}

	exceptSessionID := ""
	// TODO: Get current session ID from context if available

	if exceptCurrentValue {
		// Keep current session active
		// This would require passing the current session ID
	}

	resp, err := r.Clients.SessionClient.RevokeAllSessions(ctx, &sessionpb.RevokeAllSessionsRequest{
		UserId:          user.UserID,
		ExceptSessionId: exceptSessionID,
		RevokedByIp:     "gateway",
		Reason:          "user_requested_logout_all",
	})

	if err != nil {
		return nil, fmt.Errorf("failed to revoke all sessions: %w", err)
	}

	return &model.GenericResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// TrustDevice marks a device as trusted
func (r *mutationResolver) TrustDevice(ctx context.Context, deviceID string) (*model.GenericResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.SessionClient.TrustDevice(ctx, &sessionpb.TrustDeviceRequest{
		DeviceId: deviceID,
		UserId:   user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to trust device: %w", err)
	}

	return &model.GenericResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// ResolveSecurityAlert marks a security alert as resolved
func (r *mutationResolver) ResolveSecurityAlert(ctx context.Context, alertID string) (*model.GenericResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.AuditClient.ResolveSecurityAlert(ctx, &auditpb.ResolveSecurityAlertRequest{
		AlertId: alertID,
		UserId:  user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to resolve security alert: %w", err)
	}

	return &model.GenericResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// Me returns the current user's profile
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.AuthClient.GetUserProfile(ctx, &authpb.GetUserProfileRequest{
		UserId: user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get user profile: %w", err)
	}

	if !resp.Success {
		return nil, fmt.Errorf(resp.Message)
	}

	return &model.User{
		ID:         resp.Profile.Id,
		Email:      resp.Profile.Email,
		FullName:   resp.Profile.FullName,
		IsActive:   resp.Profile.IsActive,
		MfaEnabled: resp.Profile.MfaEnabled,
		CreatedAt:  resp.Profile.CreatedAt,
		UpdatedAt:  resp.Profile.UpdatedAt,
	}, nil
}

// ValidateToken validates a JWT token
func (r *queryResolver) ValidateToken(ctx context.Context, token string) (*model.TokenValidationResponse, error) {
	resp, err := r.Clients.AuthClient.ValidateToken(ctx, &authpb.ValidateTokenRequest{
		Token: token,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to validate token: %w", err)
	}

	return &model.TokenValidationResponse{
		Valid:   resp.Valid,
		UserID:  &resp.UserId,
		Email:   &resp.Email,
		Message: resp.Message,
	}, nil
}

// Sessions returns all sessions for the current user
func (r *queryResolver) Sessions(ctx context.Context, includeInactive *bool) (*model.SessionsResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	includeInactiveValue := false
	if includeInactive != nil {
		includeInactiveValue = *includeInactive
	}

	resp, err := r.Clients.SessionClient.GetUserSessions(ctx, &sessionpb.GetUserSessionsRequest{
		UserId:          user.UserID,
		IncludeInactive: includeInactiveValue,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get sessions: %w", err)
	}

	sessions := make([]*model.Session, len(resp.Sessions))
	for i, s := range resp.Sessions {
		sessions[i] = &model.Session{
			ID:              s.Id,
			UserID:          s.UserId,
			DeviceID:        s.DeviceId,
			DeviceName:      s.DeviceName,
			DeviceType:      s.DeviceType,
			IPAddress:       s.IpAddress,
			UserAgent:       &s.UserAgent,
			LocationCountry: &s.LocationCountry,
			LocationCity:    &s.LocationCity,
			Latitude:        &s.Latitude,
			Longitude:       &s.Longitude,
			IsActive:        s.IsActive,
			CreatedAt:       s.CreatedAt,
			LastSeenAt:      s.LastSeenAt,
			ExpiresAt:       s.ExpiresAt,
			IsCurrent:       s.IsCurrent,
		}
	}

	totalCount := int(resp.TotalCount)
	activeCount := int(resp.ActiveCount)

	return &model.SessionsResponse{
		Success:     resp.Success,
		Message:     resp.Message,
		Sessions:    sessions,
		TotalCount:  totalCount,
		ActiveCount: activeCount,
	}, nil
}

// SessionDetails returns details of a specific session
func (r *queryResolver) SessionDetails(ctx context.Context, sessionID string) (*model.Session, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.SessionClient.GetSessionDetails(ctx, &sessionpb.GetSessionDetailsRequest{
		SessionId: sessionID,
		UserId:    user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get session details: %w", err)
	}

	if !resp.Success || resp.Session == nil {
		return nil, fmt.Errorf(resp.Message)
	}

	s := resp.Session
	return &model.Session{
		ID:              s.Id,
		UserID:          s.UserId,
		DeviceID:        s.DeviceId,
		DeviceName:      s.DeviceName,
		DeviceType:      s.DeviceType,
		IPAddress:       s.IpAddress,
		UserAgent:       &s.UserAgent,
		LocationCountry: &s.LocationCountry,
		LocationCity:    &s.LocationCity,
		Latitude:        &s.Latitude,
		Longitude:       &s.Longitude,
		IsActive:        s.IsActive,
		CreatedAt:       s.CreatedAt,
		LastSeenAt:      s.LastSeenAt,
		ExpiresAt:       s.ExpiresAt,
		IsCurrent:       s.IsCurrent,
	}, nil
}

// SessionStats returns session statistics
func (r *queryResolver) SessionStats(ctx context.Context) (*model.SessionStats, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.SessionClient.GetSessionStats(ctx, &sessionpb.GetSessionStatsRequest{
		UserId: user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get session stats: %w", err)
	}

	return &model.SessionStats{
		TotalSessions:     int(resp.TotalSessions),
		ActiveSessions:    int(resp.ActiveSessions),
		TotalDevices:      int(resp.TotalDevices),
		TrustedDevices:    int(resp.TrustedDevices),
		LastLogin:         &resp.LastLogin,
		LastLoginLocation: &resp.LastLoginLocation,
		RecentLocations:   resp.RecentLocations,
	}, nil
}

// Devices returns all devices for the current user
func (r *queryResolver) Devices(ctx context.Context) (*model.DevicesResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.SessionClient.GetUserDevices(ctx, &sessionpb.GetUserDevicesRequest{
		UserId: user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get devices: %w", err)
	}

	devices := make([]*model.Device, len(resp.Devices))
	for i, d := range resp.Devices {
		devices[i] = &model.Device{
			ID:                d.Id,
			UserID:            d.UserId,
			DeviceFingerprint: d.DeviceFingerprint,
			DeviceName:        d.DeviceName,
			DeviceType:        d.DeviceType,
			Os:                d.Os,
			Browser:           d.Browser,
			IsTrusted:         d.IsTrusted,
			FirstSeenAt:       d.FirstSeenAt,
			LastSeenAt:        d.LastSeenAt,
			SessionCount:      int(d.SessionCount),
		}
	}

	totalCount := int(resp.TotalCount)
	trustedCount := int(resp.TrustedCount)

	return &model.DevicesResponse{
		Success:      resp.Success,
		Message:      resp.Message,
		Devices:      devices,
		TotalCount:   totalCount,
		TrustedCount: trustedCount,
	}, nil
}

// AuditLogs returns audit logs for the current user
func (r *queryResolver) AuditLogs(ctx context.Context, limit *int, offset *int, eventCategory *string, severity *string, successOnly *bool) (*model.AuditLogsResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	limitValue := int32(50)
	if limit != nil {
		limitValue = int32(*limit)
	}

	offsetValue := int32(0)
	if offset != nil {
		offsetValue = int32(*offset)
	}

	categoryValue := ""
	if eventCategory != nil {
		categoryValue = *eventCategory
	}

	severityValue := ""
	if severity != nil {
		severityValue = *severity
	}

	successOnlyValue := false
	if successOnly != nil {
		successOnlyValue = *successOnly
	}

	resp, err := r.Clients.AuditClient.GetUserAuditLogs(ctx, &auditpb.GetUserAuditLogsRequest{
		UserId:        user.UserID,
		Limit:         limitValue,
		Offset:        offsetValue,
		EventCategory: categoryValue,
		Severity:      severityValue,
		SuccessOnly:   successOnlyValue,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get audit logs: %w", err)
	}

	logs := make([]*model.AuditLog, len(resp.Logs))
	for i, l := range resp.Logs {
		logs[i] = &model.AuditLog{
			ID:              l.Id,
			UserID:          &l.UserId,
			SessionID:       &l.SessionId,
			DeviceID:        &l.DeviceId,
			EventType:       l.EventType,
			EventCategory:   l.EventCategory,
			Severity:        l.Severity,
			IPAddress:       &l.IpAddress,
			UserAgent:       &l.UserAgent,
			LocationCountry: &l.LocationCountry,
			LocationCity:    &l.LocationCity,
			Metadata:        &l.Metadata,
			Success:         l.Success,
			FailureReason:   &l.FailureReason,
			CreatedAt:       l.CreatedAt,
		}
	}

	totalCount := int(resp.TotalCount)

	return &model.AuditLogsResponse{
		Success:    resp.Success,
		Message:    resp.Message,
		Logs:       logs,
		TotalCount: totalCount,
	}, nil
}

// SecurityAlerts returns security alerts for the current user
func (r *queryResolver) SecurityAlerts(ctx context.Context, includeResolved *bool, severity *string) (*model.SecurityAlertsResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	includeResolvedValue := false
	if includeResolved != nil {
		includeResolvedValue = *includeResolved
	}

	severityValue := ""
	if severity != nil {
		severityValue = *severity
	}

	resp, err := r.Clients.AuditClient.GetSecurityAlerts(ctx, &auditpb.GetSecurityAlertsRequest{
		UserId:          user.UserID,
		IncludeResolved: includeResolvedValue,
		Severity:        severityValue,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get security alerts: %w", err)
	}

	alerts := make([]*model.SecurityAlert, len(resp.Alerts))
	for i, a := range resp.Alerts {
		alerts[i] = &model.SecurityAlert{
			ID:              a.Id,
			UserID:          a.UserId,
			AlertType:       a.AlertType,
			Severity:        a.Severity,
			Description:     a.Description,
			Metadata:        &a.Metadata,
			IPAddress:       &a.IpAddress,
			LocationCountry: &a.LocationCountry,
			LocationCity:    &a.LocationCity,
			IsResolved:      a.IsResolved,
			ResolvedAt:      &a.ResolvedAt,
			CreatedAt:       a.CreatedAt,
		}
	}

	totalCount := int(resp.TotalCount)
	unresolvedCount := int(resp.UnresolvedCount)

	return &model.SecurityAlertsResponse{
		Success:         resp.Success,
		Message:         resp.Message,
		Alerts:          alerts,
		TotalCount:      totalCount,
		UnresolvedCount: unresolvedCount,
	}, nil
}

// ComplianceReport generates a compliance report
func (r *queryResolver) ComplianceReport(ctx context.Context, startDate *string, endDate *string) (*model.ComplianceReport, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	startDateValue := ""
	if startDate != nil {
		startDateValue = *startDate
	}

	endDateValue := ""
	if endDate != nil {
		endDateValue = *endDate
	}

	resp, err := r.Clients.AuditClient.GetComplianceReport(ctx, &auditpb.GetComplianceReportRequest{
		UserId:    user.UserID,
		StartDate: startDateValue,
		EndDate:   endDateValue,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get compliance report: %w", err)
	}

	eventBreakdown := make([]*model.EventCount, len(resp.EventBreakdown))
	for i, ec := range resp.EventBreakdown {
		eventBreakdown[i] = &model.EventCount{
			EventType: ec.EventType,
			Count:     int(ec.Count),
		}
	}

	return &model.ComplianceReport{
		TotalEvents:        int(resp.TotalEvents),
		SuccessfulLogins:   int(resp.SuccessfulLogins),
		FailedLogins:       int(resp.FailedLogins),
		SessionRevocations: int(resp.SessionRevocations),
		SecurityAlerts:     int(resp.SecurityAlerts),
		MfaEvents:          int(resp.MfaEvents),
		EventBreakdown:     eventBreakdown,
		TopLocations:       resp.TopLocations,
	}, nil
}

// ActivitySummary returns an activity summary
func (r *queryResolver) ActivitySummary(ctx context.Context, days *int) (*model.ActivitySummary, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	daysValue := int32(30)
	if days != nil {
		daysValue = int32(*days)
	}

	resp, err := r.Clients.AuditClient.GetActivitySummary(ctx, &auditpb.GetActivitySummaryRequest{
		UserId: user.UserID,
		Days:   daysValue,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get activity summary: %w", err)
	}

	dailyActivity := make([]*model.DailyActivity, len(resp.DailyActivity))
	for i, da := range resp.DailyActivity {
		dailyActivity[i] = &model.DailyActivity{
			Date:             da.Date,
			LoginCount:       int(da.LoginCount),
			FailedLoginCount: int(da.FailedLoginCount),
		}
	}

	return &model.ActivitySummary{
		TotalLogins:         int(resp.TotalLogins),
		FailedLoginAttempts: int(resp.FailedLoginAttempts),
		UniqueDevices:       int(resp.UniqueDevices),
		UniqueLocations:     int(resp.UniqueLocations),
		DailyActivity:       dailyActivity,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) EnableMFA(ctx context.Context) (*model.MFASetup, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.AuthClient.EnableMFA(ctx, &authpb.EnableMFARequest{
		UserId: user.UserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to enable MFA: %w", err)
	}

	return &model.MFASetup{
		Success:     resp.Success,
		Message:     resp.Message,
		Secret:      &resp.Secret,
		QRCodeURL:   &resp.QrCodeUrl,
		BackupCodes: resp.BackupCodes,
	}, nil
}
func (r *mutationResolver) VerifyMFA(ctx context.Context, code string) (*model.GenericResponse, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	resp, err := r.Clients.AuthClient.VerifyMFA(ctx, &authpb.VerifyMFARequest{
		UserId: user.UserID,
		Code:   code,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to verify MFA: %w", err)
	}

	return &model.GenericResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}
func stringToValue(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
func float64ToValue(f *float64) float64 {
	if f == nil {
		return 0.0
	}
	return *f
}
type MutationResolver interface {
	Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error)
	Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error)
	RefreshToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error)
	EnableMFA(ctx context.Context) (*model.MFASetup, error)
	VerifyMFA(ctx context.Context, code string) (*model.GenericResponse, error)
	RevokeSession(ctx context.Context, sessionID string) (*model.GenericResponse, error)
	RevokeAllSessions(ctx context.Context, exceptCurrent *bool) (*model.GenericResponse, error)
	TrustDevice(ctx context.Context, deviceID string) (*model.GenericResponse, error)
	ResolveSecurityAlert(ctx context.Context, alertID string) (*model.GenericResponse, error)
}
type QueryResolver interface {
	Me(ctx context.Context) (*model.User, error)
	ValidateToken(ctx context.Context, token string) (*model.TokenValidationResponse, error)
	Sessions(ctx context.Context, includeInactive *bool) (*model.SessionsResponse, error)
	SessionDetails(ctx context.Context, sessionID string) (*model.Session, error)
	SessionStats(ctx context.Context) (*model.SessionStats, error)
	Devices(ctx context.Context) (*model.DevicesResponse, error)
	AuditLogs(ctx context.Context, limit *int, offset *int, eventCategory *string, severity *string, successOnly *bool) (*model.AuditLogsResponse, error)
	SecurityAlerts(ctx context.Context, includeResolved *bool, severity *string) (*model.SecurityAlertsResponse, error)
	ComplianceReport(ctx context.Context, startDate *string, endDate *string) (*model.ComplianceReport, error)
	ActivitySummary(ctx context.Context, days *int) (*model.ActivitySummary, error)
}
*/
